import { ReportConfig } from '../core/ReportConfig';
import { ReportData, ReportTheme } from '../types/reporting.types';
import { Logger } from '../../core/utils/Logger';
import { DateUtils } from '../../core/utils/DateUtils';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Generates custom HTML reports with zero dependencies
 * All charts, components, and interactions built from scratch
 */
export class HTMLReportGenerator {
    private logger: Logger;
    private config: ReportConfig;
    private theme: ReportTheme;

    constructor() {
        this.logger = new Logger('HTMLReportGenerator');
    }

    /**
     * Initialize the generator
     */
    public async initialize(config: ReportConfig): Promise<void> {
        this.config = config;
        this.theme = config.getTheme();
        this.logger.info('HTML report generator initialized');
    }

    /**
     * Generate complete HTML report
     */
    public async generate(data: any): Promise<string> {
        try {
            this.logger.info('Generating HTML report');
            const startTime = Date.now();

            // Build complete HTML document
            const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${data.reportData.reportMetadata.reportTitle} - ${data.reportData.reportMetadata.reportId}</title>
    <meta name="description" content="${data.reportData.reportMetadata.reportTitle} generated by CS Test Automation Framework">
    <meta name="generator" content="CS Test Automation Framework">
    <meta name="theme-color" content="${this.theme.primaryColor}">
    
    <style>
${this.generateCompleteCSS()}
    </style>
</head>
<body>
    <!-- Custom SVG Definitions -->
    <svg style="display: none;">
        <defs>
${this.generateSVGDefinitions()}
        </defs>
    </svg>
    
    <!-- Main Report Container -->
    <div class="cs-report" id="cs-report">
        <!-- Header -->
${this.generateHeader(data.reportData.reportMetadata)}
        
        <!-- Navigation -->
${this.generateNavigation()}
        
        <!-- Summary Section -->
        <section id="summary" class="cs-section cs-summary-section">
${this.generateSummarySection(data.summary)}
        </section>
        
        <!-- Dashboard Section -->
        <section id="dashboard" class="cs-section cs-dashboard-section">
${this.generateDashboard(data.dashboard)}
        </section>
        
        <!-- Features Section -->
        <section id="features" class="cs-section cs-features-section">
${this.generateFeaturesSection(data.features)}
        </section>
        
        <!-- Scenarios Section -->
        <section id="scenarios" class="cs-section cs-scenarios-section">
${this.generateScenariosSection(data.scenarios)}
        </section>
        
        <!-- Timeline Section -->
        ${data.timeline ? `<section id="timeline" class="cs-section cs-timeline-section">
${this.generateTimelineSection(data.timeline)}
        </section>` : ''}
        
        <!-- Gallery Section -->
        ${data.gallery ? `<section id="gallery" class="cs-section cs-gallery-section">
${this.generateGallerySection(data.gallery)}
        </section>` : ''}
        
        <!-- Metrics Section -->
        <section id="metrics" class="cs-section cs-metrics-section">
${this.generateMetricsSection(data.metrics)}
        </section>
        
        <!-- Footer -->
${this.generateFooter(data.reportData.reportMetadata)}
    </div>
    
    <!-- Lightbox -->
    <div id="cs-lightbox" class="cs-lightbox">
        <span class="cs-lightbox-close">&times;</span>
        <img class="cs-lightbox-content" id="cs-lightbox-img">
        <div class="cs-lightbox-caption"></div>
    </div>
    
    <!-- Search Modal -->
    <div id="cs-search-modal" class="cs-modal">
        <div class="cs-modal-content">
            <span class="cs-modal-close">&times;</span>
            <h2>Search Report</h2>
            <input type="text" id="cs-search-input" class="cs-search-input" placeholder="Search scenarios, features, or errors...">
            <div id="cs-search-results" class="cs-search-results"></div>
        </div>
    </div>
    
    <script>
${this.generateCompleteJavaScript(data)}
    </script>
</body>
</html>`;

            const duration = Date.now() - startTime;
            this.logger.info(`HTML report generated in ${duration}ms`);
            
            return html;

        } catch (error) {
            this.logger.error('Failed to generate HTML report', error);
            throw error;
        }
    }

    /**
     * Generate live report (simplified version)
     */
    public async generateLive(data: any): Promise<string> {
        return this.generate({
            ...data,
            isLive: true
        });
    }

    /**
     * Finalize generator
     */
    public async finalize(): Promise<void> {
        // Cleanup if needed
    }

    /**
     * Generate complete custom CSS
     */
    private generateCompleteCSS(): string {
        return `
/* CS Test Automation Framework - Custom Report Styles */
/* Brand Primary Color: ${this.theme.primaryColor} */

/* CSS Variables */
:root {
    --cs-primary: ${this.theme.primaryColor};
    --cs-primary-rgb: ${this.hexToRgb(this.theme.primaryColor).join(', ')};
    --cs-secondary: ${this.theme.secondaryColor};
    --cs-accent: ${this.theme.accentColor};
    --cs-success: ${this.theme.successColor};
    --cs-error: ${this.theme.errorColor};
    --cs-warning: ${this.theme.warningColor};
    --cs-info: ${this.theme.infoColor};
    
    --cs-gradient-primary: linear-gradient(135deg, var(--cs-primary) 0%, var(--cs-accent) 100%);
    --cs-gradient-success: linear-gradient(135deg, var(--cs-success) 0%, #20C997 100%);
    --cs-gradient-error: linear-gradient(135deg, var(--cs-error) 0%, #C82333 100%);
    --cs-gradient-warning: linear-gradient(135deg, var(--cs-warning) 0%, #E0A800 100%);
    
    --cs-bg: #FFFFFF;
    --cs-bg-secondary: #F8F9FA;
    --cs-text: #333333;
    --cs-text-secondary: #6C757D;
    --cs-border: #E0E0E0;
    --cs-shadow: rgba(0, 0, 0, 0.1);
    
    --cs-spacing-xs: 0.25rem;
    --cs-spacing-sm: 0.5rem;
    --cs-spacing-md: 1rem;
    --cs-spacing-lg: 1.5rem;
    --cs-spacing-xl: 2rem;
    --cs-spacing-xxl: 3rem;
    
    --cs-radius-sm: 0.25rem;
    --cs-radius-md: 0.5rem;
    --cs-radius-lg: 1rem;
    --cs-radius-xl: 1.5rem;
    --cs-radius-full: 9999px;
    
    --cs-transition-fast: 150ms ease-in-out;
    --cs-transition-normal: 300ms ease-in-out;
    --cs-transition-slow: 500ms ease-in-out;
    
    --cs-font-family: ${this.theme.fontFamily};
}

/* Reset & Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    scroll-behavior: smooth;
}

body {
    font-family: var(--cs-font-family);
    color: var(--cs-text);
    background-color: var(--cs-bg);
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* Custom Scrollbar */
::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

::-webkit-scrollbar-track {
    background: var(--cs-bg-secondary);
}

::-webkit-scrollbar-thumb {
    background: var(--cs-primary);
    border-radius: var(--cs-radius-full);
    transition: background var(--cs-transition-fast);
}

::-webkit-scrollbar-thumb:hover {
    background: var(--cs-accent);
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    line-height: 1.2;
    margin-bottom: var(--cs-spacing-md);
    color: var(--cs-text);
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.75rem; }
h4 { font-size: 1.5rem; }
h5 { font-size: 1.25rem; }
h6 { font-size: 1rem; }

p {
    margin-bottom: var(--cs-spacing-md);
}

a {
    color: var(--cs-primary);
    text-decoration: none;
    transition: color var(--cs-transition-fast);
}

a:hover {
    color: var(--cs-accent);
    text-decoration: underline;
}

/* Main Report Container */
.cs-report {
    min-height: 100vh;
    background: var(--cs-bg);
    position: relative;
    overflow-x: hidden;
}

/* Header Styles */
.cs-header {
    background: var(--cs-gradient-primary);
    color: white;
    padding: var(--cs-spacing-xl) 0;
    box-shadow: 0 2px 20px var(--cs-shadow);
    position: relative;
    overflow: hidden;
}

.cs-header::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    animation: float 20s ease-in-out infinite;
}

@keyframes float {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    33% { transform: translate(30px, -30px) rotate(120deg); }
    66% { transform: translate(-20px, 20px) rotate(240deg); }
}

.cs-header-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 var(--cs-spacing-lg);
    position: relative;
    z-index: 1;
}

.cs-header-title {
    font-size: 3rem;
    font-weight: 700;
    margin-bottom: var(--cs-spacing-sm);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
}

.cs-header-subtitle {
    font-size: 1.25rem;
    opacity: 0.9;
}

.cs-header-meta {
    display: flex;
    gap: var(--cs-spacing-xl);
    margin-top: var(--cs-spacing-lg);
    flex-wrap: wrap;
}

.cs-header-meta-item {
    display: flex;
    align-items: center;
    gap: var(--cs-spacing-sm);
}

.cs-header-meta-icon {
    width: 24px;
    height: 24px;
    fill: currentColor;
}

/* Navigation */
.cs-nav {
    background: var(--cs-bg);
    box-shadow: 0 2px 10px var(--cs-shadow);
    position: sticky;
    top: 0;
    z-index: 1000;
    backdrop-filter: blur(10px);
    background: rgba(255,255,255,0.95);
}

.cs-nav-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 var(--cs-spacing-lg);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.cs-nav-links {
    display: flex;
    gap: var(--cs-spacing-xl);
    list-style: none;
}

.cs-nav-link {
    display: inline-block;
    padding: var(--cs-spacing-md) 0;
    color: var(--cs-text);
    font-weight: 500;
    position: relative;
    transition: color var(--cs-transition-fast);
}

.cs-nav-link::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 0;
    height: 3px;
    background: var(--cs-primary);
    transition: width var(--cs-transition-normal);
}

.cs-nav-link:hover,
.cs-nav-link.active {
    color: var(--cs-primary);
}

.cs-nav-link:hover::after,
.cs-nav-link.active::after {
    width: 100%;
}

.cs-nav-actions {
    display: flex;
    gap: var(--cs-spacing-md);
}

/* Buttons */
.cs-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--cs-spacing-sm);
    padding: var(--cs-spacing-sm) var(--cs-spacing-lg);
    border: none;
    border-radius: var(--cs-radius-md);
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--cs-transition-fast);
    text-decoration: none;
    white-space: nowrap;
}

.cs-btn-primary {
    background: var(--cs-primary);
    color: white;
}

.cs-btn-primary:hover {
    background: var(--cs-accent);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(var(--cs-primary-rgb), 0.3);
}

.cs-btn-secondary {
    background: var(--cs-bg-secondary);
    color: var(--cs-text);
    border: 1px solid var(--cs-border);
}

.cs-btn-secondary:hover {
    background: var(--cs-bg);
    border-color: var(--cs-primary);
    color: var(--cs-primary);
}

.cs-btn-icon {
    width: 40px;
    height: 40px;
    padding: 0;
    border-radius: var(--cs-radius-full);
}

/* Sections */
.cs-section {
    padding: var(--cs-spacing-xxl) 0;
}

.cs-section:nth-child(even) {
    background: var(--cs-bg-secondary);
}

.cs-section-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 var(--cs-spacing-lg);
}

.cs-section-header {
    text-align: center;
    margin-bottom: var(--cs-spacing-xxl);
}

.cs-section-title {
    font-size: 2.5rem;
    margin-bottom: var(--cs-spacing-md);
    position: relative;
    display: inline-block;
}

.cs-section-title::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 4px;
    background: var(--cs-gradient-primary);
    border-radius: var(--cs-radius-full);
}

.cs-section-subtitle {
    font-size: 1.25rem;
    color: var(--cs-text-secondary);
}

/* Cards */
.cs-card {
    background: var(--cs-bg);
    border-radius: var(--cs-radius-lg);
    box-shadow: 0 2px 10px var(--cs-shadow);
    padding: var(--cs-spacing-xl);
    transition: all var(--cs-transition-normal);
    position: relative;
    overflow: hidden;
}

.cs-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px var(--cs-shadow);
}

.cs-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--cs-spacing-lg);
}

.cs-card-title {
    font-size: 1.5rem;
    font-weight: 600;
}

.cs-card-badge {
    display: inline-flex;
    align-items: center;
    padding: var(--cs-spacing-xs) var(--cs-spacing-md);
    border-radius: var(--cs-radius-full);
    font-size: 0.875rem;
    font-weight: 600;
    background: var(--cs-bg-secondary);
}

.cs-card-badge.success {
    background: rgba(40, 167, 69, 0.1);
    color: var(--cs-success);
}

.cs-card-badge.error {
    background: rgba(220, 53, 69, 0.1);
    color: var(--cs-error);
}

.cs-card-badge.warning {
    background: rgba(255, 193, 7, 0.1);
    color: var(--cs-warning);
}

/* Grid System */
.cs-grid {
    display: grid;
    gap: var(--cs-spacing-xl);
}

.cs-grid-2 {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}

.cs-grid-3 {
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

.cs-grid-4 {
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}

/* Stats Cards */
.cs-stat-card {
    background: var(--cs-bg);
    border-radius: var(--cs-radius-lg);
    padding: var(--cs-spacing-xl);
    box-shadow: 0 2px 10px var(--cs-shadow);
    position: relative;
    overflow: hidden;
    transition: all var(--cs-transition-normal);
}

.cs-stat-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--cs-gradient-primary);
}

.cs-stat-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px var(--cs-shadow);
}

.cs-stat-card.success::before { background: var(--cs-gradient-success); }
.cs-stat-card.error::before { background: var(--cs-gradient-error); }
.cs-stat-card.warning::before { background: var(--cs-gradient-warning); }

.cs-stat-value {
    font-size: 2.5rem;
    font-weight: 700;
    line-height: 1;
    margin-bottom: var(--cs-spacing-sm);
    background: var(--cs-gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.cs-stat-label {
    font-size: 1rem;
    color: var(--cs-text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.cs-stat-icon {
    position: absolute;
    top: 50%;
    right: var(--cs-spacing-lg);
    transform: translateY(-50%);
    width: 60px;
    height: 60px;
    opacity: 0.1;
}

/* Progress Bars */
.cs-progress {
    width: 100%;
    height: 10px;
    background: var(--cs-bg-secondary);
    border-radius: var(--cs-radius-full);
    overflow: hidden;
    position: relative;
}

.cs-progress-bar {
    height: 100%;
    background: var(--cs-gradient-primary);
    border-radius: var(--cs-radius-full);
    transition: width var(--cs-transition-slow);
    position: relative;
    overflow: hidden;
}

.cs-progress-bar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent
    );
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.cs-progress.success .cs-progress-bar { background: var(--cs-gradient-success); }
.cs-progress.error .cs-progress-bar { background: var(--cs-gradient-error); }
.cs-progress.warning .cs-progress-bar { background: var(--cs-gradient-warning); }

/* Custom Charts Container */
.cs-chart-container {
    position: relative;
    width: 100%;
    height: 400px;
    margin: var(--cs-spacing-xl) 0;
}

.cs-chart {
    width: 100%;
    height: 100%;
}

.cs-chart-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    gap: var(--cs-spacing-md);
}

.cs-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid var(--cs-bg-secondary);
    border-top-color: var(--cs-primary);
    border-radius: var(--cs-radius-full);
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Tables */
.cs-table-container {
    background: var(--cs-bg);
    border-radius: var(--cs-radius-lg);
    box-shadow: 0 2px 10px var(--cs-shadow);
    overflow: hidden;
}

.cs-table {
    width: 100%;
    border-collapse: collapse;
}

.cs-table thead {
    background: var(--cs-bg-secondary);
}

.cs-table th {
    padding: var(--cs-spacing-md);
    text-align: left;
    font-weight: 600;
    color: var(--cs-text);
    text-transform: uppercase;
    font-size: 0.875rem;
    letter-spacing: 0.05em;
    border-bottom: 2px solid var(--cs-border);
}

.cs-table td {
    padding: var(--cs-spacing-md);
    border-bottom: 1px solid var(--cs-border);
}

.cs-table tbody tr {
    transition: background var(--cs-transition-fast);
}

.cs-table tbody tr:hover {
    background: var(--cs-bg-secondary);
}

.cs-table-status {
    display: inline-flex;
    align-items: center;
    gap: var(--cs-spacing-xs);
    padding: var(--cs-spacing-xs) var(--cs-spacing-sm);
    border-radius: var(--cs-radius-full);
    font-size: 0.875rem;
    font-weight: 600;
}

.cs-table-status.passed {
    background: rgba(40, 167, 69, 0.1);
    color: var(--cs-success);
}

.cs-table-status.failed {
    background: rgba(220, 53, 69, 0.1);
    color: var(--cs-error);
}

.cs-table-status.skipped {
    background: rgba(255, 193, 7, 0.1);
    color: var(--cs-warning);
}

.cs-table-icon {
    width: 16px;
    height: 16px;
    fill: currentColor;
}

/* Timeline */
.cs-timeline {
    position: relative;
    width: 100%;
    height: 500px;
    background: var(--cs-bg);
    border-radius: var(--cs-radius-lg);
    box-shadow: 0 2px 10px var(--cs-shadow);
    overflow: hidden;
}

.cs-timeline-canvas {
    width: 100%;
    height: 100%;
    cursor: grab;
}

.cs-timeline-canvas:active {
    cursor: grabbing;
}

.cs-timeline-controls {
    position: absolute;
    top: var(--cs-spacing-md);
    right: var(--cs-spacing-md);
    display: flex;
    gap: var(--cs-spacing-sm);
    background: rgba(255, 255, 255, 0.9);
    padding: var(--cs-spacing-sm);
    border-radius: var(--cs-radius-md);
    backdrop-filter: blur(10px);
}

.cs-timeline-tooltip {
    position: absolute;
    background: var(--cs-text);
    color: white;
    padding: var(--cs-spacing-sm) var(--cs-spacing-md);
    border-radius: var(--cs-radius-md);
    font-size: 0.875rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity var(--cs-transition-fast);
    box-shadow: 0 4px 12px var(--cs-shadow);
    z-index: 1000;
}

.cs-timeline-tooltip.visible {
    opacity: 1;
}

/* Gallery */
.cs-gallery {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--cs-spacing-lg);
}

.cs-gallery-item {
    position: relative;
    aspect-ratio: 16/9;
    border-radius: var(--cs-radius-md);
    overflow: hidden;
    cursor: pointer;
    transition: all var(--cs-transition-normal);
}

.cs-gallery-item:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 24px var(--cs-shadow);
}

.cs-gallery-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.cs-gallery-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(to bottom, transparent 60%, rgba(0,0,0,0.7));
    opacity: 0;
    transition: opacity var(--cs-transition-fast);
    display: flex;
    align-items: flex-end;
    padding: var(--cs-spacing-md);
}

.cs-gallery-item:hover .cs-gallery-overlay {
    opacity: 1;
}

.cs-gallery-caption {
    color: white;
    font-size: 0.875rem;
}

/* Lightbox */
.cs-lightbox {
    display: none;
    position: fixed;
    z-index: 9999;
    inset: 0;
    background: rgba(0, 0, 0, 0.9);
    animation: fadeIn var(--cs-transition-normal);
}

.cs-lightbox.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.cs-lightbox-content {
    max-width: 90%;
    max-height: 90%;
    object-fit: contain;
    animation: zoomIn var(--cs-transition-normal);
}

.cs-lightbox-close {
    position: absolute;
    top: var(--cs-spacing-xl);
    right: var(--cs-spacing-xl);
    font-size: 3rem;
    color: white;
    cursor: pointer;
    transition: color var(--cs-transition-fast);
}

.cs-lightbox-close:hover {
    color: var(--cs-primary);
}

.cs-lightbox-caption {
    position: absolute;
    bottom: var(--cs-spacing-xl);
    left: 50%;
    transform: translateX(-50%);
    color: white;
    text-align: center;
    padding: var(--cs-spacing-md) var(--cs-spacing-xl);
    background: rgba(0, 0, 0, 0.7);
    border-radius: var(--cs-radius-md);
}

/* Modal */
.cs-modal {
    display: none;
    position: fixed;
    z-index: 9998;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
}

.cs-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn var(--cs-transition-fast);
}

.cs-modal-content {
    background: var(--cs-bg);
    padding: var(--cs-spacing-xxl);
    border-radius: var(--cs-radius-lg);
    box-shadow: 0 20px 50px var(--cs-shadow);
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    animation: slideUp var(--cs-transition-normal);
}

.cs-modal-close {
    position: absolute;
    top: var(--cs-spacing-md);
    right: var(--cs-spacing-md);
    font-size: 2rem;
    color: var(--cs-text-secondary);
    cursor: pointer;
    transition: color var(--cs-transition-fast);
}

.cs-modal-close:hover {
    color: var(--cs-text);
}

/* Search */
.cs-search-input {
    width: 100%;
    padding: var(--cs-spacing-md);
    border: 2px solid var(--cs-border);
    border-radius: var(--cs-radius-md);
    font-size: 1rem;
    transition: border-color var(--cs-transition-fast);
    margin-top: var(--cs-spacing-lg);
}

.cs-search-input:focus {
    outline: none;
    border-color: var(--cs-primary);
}

.cs-search-results {
    margin-top: var(--cs-spacing-xl);
}

.cs-search-result {
    padding: var(--cs-spacing-md);
    border: 1px solid var(--cs-border);
    border-radius: var(--cs-radius-md);
    margin-bottom: var(--cs-spacing-md);
    cursor: pointer;
    transition: all var(--cs-transition-fast);
}

.cs-search-result:hover {
    border-color: var(--cs-primary);
    background: var(--cs-bg-secondary);
}

.cs-search-result-title {
    font-weight: 600;
    margin-bottom: var(--cs-spacing-xs);
}

.cs-search-result-context {
    font-size: 0.875rem;
    color: var(--cs-text-secondary);
}

.cs-search-highlight {
    background: yellow;
    font-weight: 600;
}

/* Tags */
.cs-tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--cs-spacing-sm);
}

.cs-tag {
    display: inline-flex;
    align-items: center;
    padding: var(--cs-spacing-xs) var(--cs-spacing-md);
    background: var(--cs-bg-secondary);
    border-radius: var(--cs-radius-full);
    font-size: 0.875rem;
    color: var(--cs-text);
    transition: all var(--cs-transition-fast);
}

.cs-tag:hover {
    background: var(--cs-primary);
    color: white;
}

/* Tooltips */
.cs-tooltip {
    position: relative;
    display: inline-block;
}

.cs-tooltip-content {
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background: var(--cs-text);
    color: white;
    padding: var(--cs-spacing-sm) var(--cs-spacing-md);
    border-radius: var(--cs-radius-md);
    font-size: 0.875rem;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: all var(--cs-transition-fast);
    box-shadow: 0 4px 12px var(--cs-shadow);
    z-index: 1000;
}

.cs-tooltip-content::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: var(--cs-text);
}

.cs-tooltip:hover .cs-tooltip-content {
    opacity: 1;
    visibility: visible;
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes zoomIn {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

/* Responsive Design */
@media (max-width: 1024px) {
    .cs-grid-4 {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }
    
    .cs-header-title {
        font-size: 2.5rem;
    }
    
    .cs-stat-value {
        font-size: 2rem;
    }
}

@media (max-width: 768px) {
    .cs-nav-content {
        flex-direction: column;
        gap: var(--cs-spacing-md);
    }
    
    .cs-nav-links {
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .cs-grid-3,
    .cs-grid-4 {
        grid-template-columns: repeat(auto-fit, minmax(100%, 1fr));
    }
    
    .cs-header-title {
        font-size: 2rem;
    }
    
    .cs-section-title {
        font-size: 2rem;
    }
    
    .cs-modal-content {
        padding: var(--cs-spacing-lg);
    }
}

@media (max-width: 480px) {
    .cs-grid-2 {
        grid-template-columns: 1fr;
    }
    
    .cs-header-meta {
        flex-direction: column;
        gap: var(--cs-spacing-md);
    }
    
    .cs-gallery {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    }
}

/* Print Styles */
@media print {
    .cs-nav,
    .cs-nav-actions,
    .cs-btn,
    .cs-lightbox,
    .cs-modal {
        display: none !important;
    }
    
    .cs-section {
        page-break-inside: avoid;
    }
    
    .cs-card {
        box-shadow: none;
        border: 1px solid var(--cs-border);
    }
    
    body {
        font-size: 12pt;
    }
}

/* Utility Classes */
.cs-text-center { text-align: center; }
.cs-text-left { text-align: left; }
.cs-text-right { text-align: right; }
.cs-text-primary { color: var(--cs-primary); }
.cs-text-success { color: var(--cs-success); }
.cs-text-error { color: var(--cs-error); }
.cs-text-warning { color: var(--cs-warning); }
.cs-text-muted { color: var(--cs-text-secondary); }
.cs-mb-0 { margin-bottom: 0; }
.cs-mb-1 { margin-bottom: var(--cs-spacing-sm); }
.cs-mb-2 { margin-bottom: var(--cs-spacing-md); }
.cs-mb-3 { margin-bottom: var(--cs-spacing-lg); }
.cs-mb-4 { margin-bottom: var(--cs-spacing-xl); }
.cs-hidden { display: none; }
.cs-flex { display: flex; }
.cs-flex-center { display: flex; align-items: center; justify-content: center; }
.cs-flex-between { display: flex; justify-content: space-between; align-items: center; }
.cs-gap-1 { gap: var(--cs-spacing-sm); }
.cs-gap-2 { gap: var(--cs-spacing-md); }
.cs-gap-3 { gap: var(--cs-spacing-lg); }
`;
    }

    /**
     * Generate complete JavaScript with all custom implementations
     */
    private generateCompleteJavaScript(data: any): string {
        return `
// CS Test Automation Framework - Custom Report JavaScript
// All charts and components built from scratch - NO external dependencies

(function() {
    'use strict';
    
    // Global state
    const CSReport = {
        data: ${JSON.stringify(data)},
        charts: {},
        components: {},
        state: {
            activeSection: 'summary',
            searchQuery: '',
            filters: {
                status: 'all',
                feature: 'all',
                tag: 'all'
            }
        }
    };
    
    // Custom Chart Library
    class CSChart {
        constructor(container, options = {}) {
            this.container = typeof container === 'string' ? document.getElementById(container) : container;
            this.options = {
                width: options.width || this.container.offsetWidth,
                height: options.height || 400,
                margin: options.margin || { top: 20, right: 20, bottom: 40, left: 60 },
                colors: options.colors || [
                    '${this.theme.primaryColor}',
                    '${this.theme.successColor}',
                    '${this.theme.errorColor}',
                    '${this.theme.warningColor}',
                    '${this.theme.infoColor}',
                    '${this.theme.accentColor}'
                ],
                animations: options.animations !== false,
                ...options
            };
            
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.options.width;
            this.canvas.height = this.options.height;
            this.container.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            
            this.animationFrame = null;
            this.tooltip = this.createTooltip();
            
            // Event handling
            this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
            this.canvas.addEventListener('click', this.handleClick.bind(this));
        }
        
        createTooltip() {
            const tooltip = document.createElement('div');
            tooltip.className = 'cs-chart-tooltip';
            tooltip.style.cssText = \`
                position: absolute;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 14px;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s;
                z-index: 1000;
            \`;
            document.body.appendChild(tooltip);
            return tooltip;
        }
        
        showTooltip(x, y, content) {
            const rect = this.canvas.getBoundingClientRect();
            this.tooltip.innerHTML = content;
            this.tooltip.style.left = (rect.left + x) + 'px';
            this.tooltip.style.top = (rect.top + y - 40) + 'px';
            this.tooltip.style.opacity = '1';
        }
        
        hideTooltip() {
            this.tooltip.style.opacity = '0';
        }
        
        handleMouseMove(e) {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            this.onMouseMove(x, y);
        }
        
        handleMouseLeave() {
            this.hideTooltip();
            this.onMouseLeave();
        }
        
        handleClick(e) {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            this.onClick(x, y);
        }
        
        onMouseMove(x, y) {}
        onMouseLeave() {}
        onClick(x, y) {}
        
        clear() {
            this.ctx.clearRect(0, 0, this.options.width, this.options.height);
        }
        
        destroy() {
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
            }
            if (this.tooltip && this.tooltip.parentNode) {
                this.tooltip.parentNode.removeChild(this.tooltip);
            }
            this.canvas.remove();
        }
    }
    
    // Doughnut Chart Implementation
    class CSDoughnutChart extends CSChart {
        constructor(container, data, options = {}) {
            super(container, options);
            this.data = data;
            this.centerX = this.options.width / 2;
            this.centerY = this.options.height / 2;
            this.radius = Math.min(this.options.width, this.options.height) / 2 - 40;
            this.innerRadius = this.radius * 0.6;
            this.segments = [];
            this.hoveredSegment = null;
            this.animationProgress = 0;
            
            this.processData();
            this.animate();
        }
        
        processData() {
            const total = this.data.reduce((sum, item) => sum + item.value, 0);
            let currentAngle = -Math.PI / 2;
            
            this.data.forEach((item, index) => {
                const angle = (item.value / total) * Math.PI * 2;
                this.segments.push({
                    startAngle: currentAngle,
                    endAngle: currentAngle + angle,
                    color: this.options.colors[index % this.options.colors.length],
                    data: item,
                    percentage: ((item.value / total) * 100).toFixed(1)
                });
                currentAngle += angle;
            });
        }
        
        animate() {
            if (!this.options.animations || this.animationProgress >= 1) {
                this.animationProgress = 1;
                this.draw();
                return;
            }
            
            this.animationProgress += 0.02;
            this.animationProgress = Math.min(this.animationProgress, 1);
            this.draw();
            
            this.animationFrame = requestAnimationFrame(() => this.animate());
        }
        
        draw() {
            this.clear();
            
            // Draw segments
            this.segments.forEach((segment, index) => {
                const isHovered = this.hoveredSegment === index;
                const offset = isHovered ? 10 : 0;
                const midAngle = (segment.startAngle + segment.endAngle) / 2;
                const offsetX = Math.cos(midAngle) * offset;
                const offsetY = Math.sin(midAngle) * offset;
                
                this.ctx.save();
                this.ctx.translate(offsetX, offsetY);
                
                // Draw segment
                this.ctx.beginPath();
                this.ctx.arc(
                    this.centerX,
                    this.centerY,
                    this.radius,
                    segment.startAngle,
                    segment.startAngle + (segment.endAngle - segment.startAngle) * this.animationProgress
                );
                this.ctx.arc(
                    this.centerX,
                    this.centerY,
                    this.innerRadius,
                    segment.startAngle + (segment.endAngle - segment.startAngle) * this.animationProgress,
                    segment.startAngle,
                    true
                );
                this.ctx.closePath();
                
                this.ctx.fillStyle = segment.color;
                this.ctx.fill();
                
                // Draw border
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                this.ctx.restore();
                
                // Draw label
                if (this.animationProgress === 1) {
                    const labelRadius = this.radius + 30;
                    const labelX = this.centerX + Math.cos(midAngle) * labelRadius;
                    const labelY = this.centerY + Math.sin(midAngle) * labelRadius;
                    
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '14px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(segment.percentage + '%', labelX, labelY);
                }
            });
            
            // Draw center text
            this.ctx.fillStyle = '#333';
            this.ctx.font = 'bold 24px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(this.options.centerText || '', this.centerX, this.centerY - 10);
            
            this.ctx.font = '16px sans-serif';
            this.ctx.fillStyle = '#666';
            this.ctx.fillText(this.options.centerSubtext || '', this.centerX, this.centerY + 15);
        }
        
        onMouseMove(x, y) {
            const dx = x - this.centerX;
            const dy = y - this.centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < this.innerRadius || distance > this.radius) {
                if (this.hoveredSegment !== null) {
                    this.hoveredSegment = null;
                    this.draw();
                }
                this.hideTooltip();
                return;
            }
            
            let angle = Math.atan2(dy, dx);
            if (angle < -Math.PI / 2) angle += Math.PI * 2;
            
            for (let i = 0; i < this.segments.length; i++) {
                const segment = this.segments[i];
                if (angle >= segment.startAngle && angle <= segment.endAngle) {
                    if (this.hoveredSegment !== i) {
                        this.hoveredSegment = i;
                        this.draw();
                    }
                    this.showTooltip(x, y, \`
                        <strong>\${segment.data.label}</strong><br>
                        Value: \${segment.data.value}<br>
                        Percentage: \${segment.percentage}%
                    \`);
                    return;
                }
            }
            
            if (this.hoveredSegment !== null) {
                this.hoveredSegment = null;
                this.draw();
            }
            this.hideTooltip();
        }
        
        onMouseLeave() {
            if (this.hoveredSegment !== null) {
                this.hoveredSegment = null;
                this.draw();
            }
        }
        
        onClick(x, y) {
            const dx = x - this.centerX;
            const dy = y - this.centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < this.innerRadius || distance > this.radius) return;
            
            let angle = Math.atan2(dy, dx);
            if (angle < -Math.PI / 2) angle += Math.PI * 2;
            
            for (let i = 0; i < this.segments.length; i++) {
                const segment = this.segments[i];
                if (angle >= segment.startAngle && angle <= segment.endAngle) {
                    if (this.options.onClick) {
                        this.options.onClick(segment.data);
                    }
                    break;
                }
            }
        }
    }
    
    // Bar Chart Implementation
    class CSBarChart extends CSChart {
        constructor(container, data, options = {}) {
            super(container, options);
            this.data = data;
            this.bars = [];
            this.hoveredBar = null;
            this.animationProgress = 0;
            
            this.processData();
            this.animate();
        }
        
        processData() {
            const chartWidth = this.options.width - this.options.margin.left - this.options.margin.right;
            const chartHeight = this.options.height - this.options.margin.top - this.options.margin.bottom;
            const barWidth = chartWidth / this.data.length * 0.8;
            const barSpacing = chartWidth / this.data.length * 0.2;
            const maxValue = Math.max(...this.data.map(d => d.value));
            
            this.data.forEach((item, index) => {
                const barHeight = (item.value / maxValue) * chartHeight;
                this.bars.push({
                    x: this.options.margin.left + index * (barWidth + barSpacing) + barSpacing / 2,
                    y: this.options.margin.top + chartHeight - barHeight,
                    width: barWidth,
                    height: barHeight,
                    color: this.options.colors[index % this.options.colors.length],
                    data: item
                });
            });
        }
        
        animate() {
            if (!this.options.animations || this.animationProgress >= 1) {
                this.animationProgress = 1;
                this.draw();
                return;
            }
            
            this.animationProgress += 0.02;
            this.animationProgress = Math.min(this.animationProgress, 1);
            this.draw();
            
            this.animationFrame = requestAnimationFrame(() => this.animate());
        }
        
        draw() {
            this.clear();
            
            // Draw axes
            this.ctx.strokeStyle = '#ddd';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(this.options.margin.left, this.options.margin.top);
            this.ctx.lineTo(this.options.margin.left, this.options.height - this.options.margin.bottom);
            this.ctx.lineTo(this.options.width - this.options.margin.right, this.options.height - this.options.margin.bottom);
            this.ctx.stroke();
            
            // Draw bars
            this.bars.forEach((bar, index) => {
                const isHovered = this.hoveredBar === index;
                const animatedHeight = bar.height * this.animationProgress;
                
                // Shadow for hovered bar
                if (isHovered) {
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowOffsetY = 5;
                }
                
                // Draw bar
                this.ctx.fillStyle = bar.color;
                this.ctx.fillRect(
                    bar.x,
                    bar.y + bar.height - animatedHeight,
                    bar.width,
                    animatedHeight
                );
                
                // Reset shadow
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetY = 0;
                
                // Draw value on top
                if (this.animationProgress === 1) {
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '12px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'bottom';
                    this.ctx.fillText(
                        bar.data.value.toString(),
                        bar.x + bar.width / 2,
                        bar.y - 5
                    );
                }
                
                // Draw label
                this.ctx.fillStyle = '#666';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'top';
                this.ctx.save();
                this.ctx.translate(bar.x + bar.width / 2, this.options.height - this.options.margin.bottom + 5);
                this.ctx.rotate(-Math.PI / 4);
                this.ctx.fillText(bar.data.label, 0, 0);
                this.ctx.restore();
            });
        }
        
        onMouseMove(x, y) {
            let hovered = null;
            
            for (let i = 0; i < this.bars.length; i++) {
                const bar = this.bars[i];
                if (x >= bar.x && x <= bar.x + bar.width &&
                    y >= bar.y && y <= bar.y + bar.height) {
                    hovered = i;
                    break;
                }
            }
            
            if (hovered !== this.hoveredBar) {
                this.hoveredBar = hovered;
                this.draw();
            }
            
            if (hovered !== null) {
                const bar = this.bars[hovered];
                this.showTooltip(x, y, \`
                    <strong>\${bar.data.label}</strong><br>
                    Value: \${bar.data.value}
                \`);
            } else {
                this.hideTooltip();
            }
        }
        
        onMouseLeave() {
            if (this.hoveredBar !== null) {
                this.hoveredBar = null;
                this.draw();
            }
        }
    }
    
    // Line Chart Implementation
    class CSLineChart extends CSChart {
        constructor(container, data, options = {}) {
            super(container, options);
            this.data = data;
            this.points = [];
            this.hoveredPoint = null;
            this.animationProgress = 0;
            
            this.processData();
            this.animate();
        }
        
        processData() {
            const chartWidth = this.options.width - this.options.margin.left - this.options.margin.right;
            const chartHeight = this.options.height - this.options.margin.top - this.options.margin.bottom;
            const maxValue = Math.max(...this.data.map(d => d.value));
            const minValue = Math.min(...this.data.map(d => d.value));
            const valueRange = maxValue - minValue;
            
            this.data.forEach((item, index) => {
                const x = this.options.margin.left + (index / (this.data.length - 1)) * chartWidth;
                const y = this.options.margin.top + chartHeight - ((item.value - minValue) / valueRange) * chartHeight;
                
                this.points.push({ x, y, data: item });
            });
        }
        
        animate() {
            if (!this.options.animations || this.animationProgress >= 1) {
                this.animationProgress = 1;
                this.draw();
                return;
            }
            
            this.animationProgress += 0.02;
            this.animationProgress = Math.min(this.animationProgress, 1);
            this.draw();
            
            this.animationFrame = requestAnimationFrame(() => this.animate());
        }
        
        draw() {
            this.clear();
            
            // Draw grid
            this.drawGrid();
            
            // Draw axes
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(this.options.margin.left, this.options.margin.top);
            this.ctx.lineTo(this.options.margin.left, this.options.height - this.options.margin.bottom);
            this.ctx.lineTo(this.options.width - this.options.margin.right, this.options.height - this.options.margin.bottom);
            this.ctx.stroke();
            
            // Draw line
            const visiblePoints = Math.floor(this.points.length * this.animationProgress);
            
            if (visiblePoints > 0) {
                // Draw area fill
                this.ctx.beginPath();
                this.ctx.moveTo(this.points[0].x, this.options.height - this.options.margin.bottom);
                
                for (let i = 0; i < visiblePoints; i++) {
                    const point = this.points[i];
                    this.ctx.lineTo(point.x, point.y);
                }
                
                if (visiblePoints > 0) {
                    this.ctx.lineTo(this.points[visiblePoints - 1].x, this.options.height - this.options.margin.bottom);
                }
                
                this.ctx.closePath();
                const gradient = this.ctx.createLinearGradient(0, this.options.margin.top, 0, this.options.height - this.options.margin.bottom);
                gradient.addColorStop(0, this.hexToRgba(this.options.colors[0], 0.3));
                gradient.addColorStop(1, this.hexToRgba(this.options.colors[0], 0.05));
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // Draw line
                this.ctx.beginPath();
                this.ctx.moveTo(this.points[0].x, this.points[0].y);
                
                for (let i = 1; i < visiblePoints; i++) {
                    const point = this.points[i];
                    const prevPoint = this.points[i - 1];
                    
                    // Smooth curve
                    const cp1x = prevPoint.x + (point.x - prevPoint.x) / 3;
                    const cp1y = prevPoint.y;
                    const cp2x = prevPoint.x + 2 * (point.x - prevPoint.x) / 3;
                    const cp2y = point.y;
                    
                    this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, point.x, point.y);
                }
                
                this.ctx.strokeStyle = this.options.colors[0];
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Draw points
                for (let i = 0; i < visiblePoints; i++) {
                    const point = this.points[i];
                    const isHovered = this.hoveredPoint === i;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, isHovered ? 8 : 5, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fill();
                    this.ctx.strokeStyle = this.options.colors[0];
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }
            
            // Draw labels
            this.drawLabels();
        }
        
        drawGrid() {
            const chartWidth = this.options.width - this.options.margin.left - this.options.margin.right;
            const chartHeight = this.options.height - this.options.margin.top - this.options.margin.bottom;
            
            this.ctx.strokeStyle = '#f0f0f0';
            this.ctx.lineWidth = 1;
            
            // Horizontal lines
            for (let i = 0; i <= 5; i++) {
                const y = this.options.margin.top + (i / 5) * chartHeight;
                this.ctx.beginPath();
                this.ctx.moveTo(this.options.margin.left, y);
                this.ctx.lineTo(this.options.width - this.options.margin.right, y);
                this.ctx.stroke();
            }
            
            // Vertical lines
            for (let i = 0; i < this.data.length; i++) {
                const x = this.options.margin.left + (i / (this.data.length - 1)) * chartWidth;
                this.ctx.beginPath();
                this.ctx.moveTo(x, this.options.margin.top);
                this.ctx.lineTo(x, this.options.height - this.options.margin.bottom);
                this.ctx.stroke();
            }
        }
        
        drawLabels() {
            this.ctx.fillStyle = '#666';
            this.ctx.font = '12px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'top';
            
            // X-axis labels
            this.points.forEach((point, index) => {
                if (index % Math.ceil(this.points.length / 10) === 0) {
                    this.ctx.fillText(
                        point.data.label,
                        point.x,
                        this.options.height - this.options.margin.bottom + 10
                    );
                }
            });
        }
        
        hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return \`rgba(\${r}, \${g}, \${b}, \${alpha})\`;
        }
        
        onMouseMove(x, y) {
            let closestPoint = null;
            let closestDistance = Infinity;
            
            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i];
                const distance = Math.sqrt(
                    Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2)
                );
                
                if (distance < 20 && distance < closestDistance) {
                    closestPoint = i;
                    closestDistance = distance;
                }
            }
            
            if (closestPoint !== this.hoveredPoint) {
                this.hoveredPoint = closestPoint;
                this.draw();
            }
            
            if (closestPoint !== null) {
                const point = this.points[closestPoint];
                this.showTooltip(x, y, \`
                    <strong>\${point.data.label}</strong><br>
                    Value: \${point.data.value}
                \`);
            } else {
                this.hideTooltip();
            }
        }
        
        onMouseLeave() {
            if (this.hoveredPoint !== null) {
                this.hoveredPoint = null;
                this.draw();
            }
        }
    }
    
    // Timeline Component
    class CSTimeline {
        constructor(container, data, options = {}) {
            this.container = typeof container === 'string' ? document.getElementById(container) : container;
            this.data = data;
            this.options = {
                height: options.height || 500,
                barHeight: options.barHeight || 30,
                barSpacing: options.barSpacing || 10,
                colors: options.colors || {
                    passed: '${this.theme.successColor}',
                    failed: '${this.theme.errorColor}',
                    skipped: '${this.theme.warningColor}'
                },
                ...options
            };
            
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.container.offsetWidth;
            this.canvas.height = this.options.height;
            this.container.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d');
            
            this.viewportStart = 0;
            this.viewportEnd = 0;
            this.scale = 1;
            this.offsetX = 0;
            this.offsetY = 0;
            this.isDragging = false;
            this.dragStartX = 0;
            this.dragStartY = 0;
            
            this.processData();
            this.setupControls();
            this.bindEvents();
            this.draw();
        }
        
        processData() {
            // Find time bounds
            let minTime = Infinity;
            let maxTime = -Infinity;
            
            this.data.forEach(item => {
                minTime = Math.min(minTime, item.start);
                maxTime = Math.max(maxTime, item.end);
            });
            
            this.timeRange = maxTime - minTime;
            this.viewportStart = minTime;
            this.viewportEnd = maxTime;
            
            // Group by feature
            const groups = {};
            this.data.forEach(item => {
                if (!groups[item.feature]) {
                    groups[item.feature] = [];
                }
                groups[item.feature].push(item);
            });
            
            this.groups = Object.entries(groups).map(([feature, items]) => ({
                feature,
                items: items.sort((a, b) => a.start - b.start)
            }));
        }
        
        setupControls() {
            const controls = document.createElement('div');
            controls.className = 'cs-timeline-controls';
            controls.innerHTML = \`
                <button class="cs-btn cs-btn-icon" id="timeline-zoom-in">+</button>
                <button class="cs-btn cs-btn-icon" id="timeline-zoom-out">-</button>
                <button class="cs-btn cs-btn-icon" id="timeline-reset"></button>
            \`;
            this.container.appendChild(controls);
            
            document.getElementById('timeline-zoom-in').addEventListener('click', () => this.zoom(1.2));
            document.getElementById('timeline-zoom-out').addEventListener('click', () => this.zoom(0.8));
            document.getElementById('timeline-reset').addEventListener('click', () => this.reset());
        }
        
        bindEvents() {
            this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
            this.canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
            this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
        }
        
        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Draw background
            this.ctx.fillStyle = '#f8f9fa';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Draw time grid
            this.drawTimeGrid();
            
            // Draw groups
            let y = 50;
            this.groups.forEach(group => {
                // Draw group label
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 14px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(group.feature, 10, y);
                y += 25;
                
                // Draw items
                group.items.forEach(item => {
                    const x = this.timeToX(item.start);
                    const width = this.timeToX(item.end) - x;
                    
                    // Draw bar
                    this.ctx.fillStyle = this.options.colors[item.status];
                    this.ctx.fillRect(x, y, width, this.options.barHeight);
                    
                    // Draw border
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(x, y, width, this.options.barHeight);
                    
                    // Draw label if wide enough
                    if (width > 100) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '12px sans-serif';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(
                            item.name.substring(0, Math.floor(width / 8)),
                            x + width / 2,
                            y + this.options.barHeight / 2 + 4
                        );
                    }
                    
                    y += this.options.barHeight + this.options.barSpacing;
                });
                
                y += 20; // Extra space between groups
            });
        }
        
        drawTimeGrid() {
            const startTime = new Date(this.viewportStart);
            const endTime = new Date(this.viewportEnd);
            const duration = endTime - startTime;
            
            // Determine grid interval
            let interval;
            if (duration < 60000) { // Less than 1 minute
                interval = 10000; // 10 seconds
            } else if (duration < 3600000) { // Less than 1 hour
                interval = 60000; // 1 minute
            } else if (duration < 86400000) { // Less than 1 day
                interval = 3600000; // 1 hour
            } else {
                interval = 86400000; // 1 day
            }
            
            // Draw grid lines
            this.ctx.strokeStyle = '#e0e0e0';
            this.ctx.lineWidth = 1;
            
            for (let time = Math.ceil(this.viewportStart / interval) * interval; 
                 time <= this.viewportEnd; 
                 time += interval) {
                const x = this.timeToX(time);
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvas.height);
                this.ctx.stroke();
                
                // Draw time label
                this.ctx.fillStyle = '#666';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    new Date(time).toLocaleTimeString(),
                    x,
                    30
                );
            }
        }
        
        timeToX(time) {
            return ((time - this.viewportStart) / (this.viewportEnd - this.viewportStart)) * 
                   this.canvas.width * this.scale + this.offsetX;
        }
        
        xToTime(x) {
            return ((x - this.offsetX) / (this.canvas.width * this.scale)) * 
                   (this.viewportEnd - this.viewportStart) + this.viewportStart;
        }
        
        zoom(factor) {
            const centerX = this.canvas.width / 2;
            const centerTime = this.xToTime(centerX);
            
            this.scale *= factor;
            this.scale = Math.max(0.1, Math.min(10, this.scale));
            
            // Adjust offset to keep center point fixed
            const newCenterX = this.timeToX(centerTime);
            this.offsetX += centerX - newCenterX;
            
            this.draw();
        }
        
        reset() {
            this.scale = 1;
            this.offsetX = 0;
            this.offsetY = 0;
            this.viewportStart = Math.min(...this.data.map(d => d.start));
            this.viewportEnd = Math.max(...this.data.map(d => d.end));
            this.draw();
        }
        
        handleMouseDown(e) {
            this.isDragging = true;
            this.dragStartX = e.offsetX;
            this.dragStartY = e.offsetY;
            this.canvas.style.cursor = 'grabbing';
        }
        
        handleMouseMove(e) {
            if (this.isDragging) {
                const dx = e.offsetX - this.dragStartX;
                const dy = e.offsetY - this.dragStartY;
                
                this.offsetX += dx;
                this.offsetY += dy;
                
                this.dragStartX = e.offsetX;
                this.dragStartY = e.offsetY;
                
                this.draw();
            }
        }
        
        handleMouseUp() {
            this.isDragging = false;
            this.canvas.style.cursor = 'grab';
        }
        
        handleMouseLeave() {
            this.isDragging = false;
            this.canvas.style.cursor = 'grab';
        }
        
        handleWheel(e) {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            this.zoom(factor);
        }
    }
    
    // Initialize Report
    function initializeReport() {
        // Smooth scroll for navigation
        document.querySelectorAll('.cs-nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                    
                    // Update active state
                    document.querySelectorAll('.cs-nav-link').forEach(l => l.classList.remove('active'));
                    link.classList.add('active');
                }
            });
        });
        
        // Search functionality
        const searchBtn = document.getElementById('search-btn');
        const searchModal = document.getElementById('cs-search-modal');
        const searchInput = document.getElementById('cs-search-input');
        const searchResults = document.getElementById('cs-search-results');
        
        if (searchBtn) {
            searchBtn.addEventListener('click', () => {
                searchModal.classList.add('active');
                searchInput.focus();
            });
        }
        
        document.querySelector('.cs-modal-close').addEventListener('click', () => {
            searchModal.classList.remove('active');
        });
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            if (query.length < 2) {
                searchResults.innerHTML = '';
                return;
            }
            
            const results = searchReport(query);
            displaySearchResults(results, query);
        });
        
        // Initialize charts
        initializeCharts();
        
        // Initialize gallery
        initializeGallery();
        
        // Initialize tables
        initializeTables();
        
        // Export functionality
        const exportBtn = document.getElementById('export-btn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                window.print();
            });
        }
    }
    
    function searchReport(query) {
        const results = [];
        
        // Search in scenarios
        CSReport.data.scenarios.data.forEach(scenario => {
            if (scenario.name.toLowerCase().includes(query) ||
                scenario.feature.toLowerCase().includes(query)) {
                results.push({
                    type: 'scenario',
                    title: scenario.name,
                    context: scenario.feature,
                    data: scenario
                });
            }
            
            // Search in steps
            scenario.steps.forEach(step => {
                if (step.name.toLowerCase().includes(query)) {
                    results.push({
                        type: 'step',
                        title: step.name,
                        context: scenario.name,
                        data: step
                    });
                }
                
                // Search in errors
                if (step.error && step.error.message.toLowerCase().includes(query)) {
                    results.push({
                        type: 'error',
                        title: step.error.message,
                        context: \`\${scenario.name} > \${step.name}\`,
                        data: step
                    });
                }
            });
        });
        
        return results.slice(0, 20); // Limit to 20 results
    }
    
    function displaySearchResults(results, query) {
        const searchResults = document.getElementById('cs-search-results');
        
        if (results.length === 0) {
            searchResults.innerHTML = '<p class="cs-text-muted">No results found</p>';
            return;
        }
        
        searchResults.innerHTML = results.map(result => \`
            <div class="cs-search-result" data-type="\${result.type}">
                <div class="cs-search-result-title">
                    \${highlightText(result.title, query)}
                </div>
                <div class="cs-search-result-context">
                    \${result.context}
                </div>
            </div>
        \`).join('');
        
        // Add click handlers
        searchResults.querySelectorAll('.cs-search-result').forEach((el, index) => {
            el.addEventListener('click', () => {
                const result = results[index];
                navigateToResult(result);
                document.getElementById('cs-search-modal').classList.remove('active');
            });
        });
    }
    
    function highlightText(text, query) {
        const regex = new RegExp(\`(\${query})\`, 'gi');
        return text.replace(regex, '<span class="cs-search-highlight">$1</span>');
    }
    
    function navigateToResult(result) {
        // Navigate to appropriate section based on result type
        switch (result.type) {
            case 'scenario':
                document.getElementById('scenarios').scrollIntoView({ behavior: 'smooth' });
                // Highlight scenario
                setTimeout(() => {
                    const scenarioEl = document.querySelector(\`[data-scenario-id="\${result.data.id}"]\`);
                    if (scenarioEl) {
                        scenarioEl.classList.add('highlight');
                        setTimeout(() => scenarioEl.classList.remove('highlight'), 3000);
                    }
                }, 500);
                break;
            case 'step':
            case 'error':
                document.getElementById('scenarios').scrollIntoView({ behavior: 'smooth' });
                break;
        }
    }
    
    function initializeCharts() {
        // Summary charts
        if (CSReport.data.summary) {
            // Scenario status distribution
            const scenarioData = [
                { label: 'Passed', value: CSReport.data.summary.passedScenarios },
                { label: 'Failed', value: CSReport.data.summary.failedScenarios },
                { label: 'Skipped', value: CSReport.data.summary.skippedScenarios }
            ];
            
            new CSDoughnutChart('scenario-status-chart', scenarioData, {
                centerText: CSReport.data.summary.totalScenarios,
                centerSubtext: 'Total Scenarios'
            });
            
            // Feature performance
            if (CSReport.data.features && CSReport.data.features.data) {
                const featureData = CSReport.data.features.data.slice(0, 10).map(feature => ({
                    label: feature.name,
                    value: feature.duration
                }));
                
                new CSBarChart('feature-performance-chart', featureData);
            }
        }
        
        // Dashboard charts
        if (CSReport.data.dashboard && CSReport.data.dashboard.charts) {
            // Execution trend
            if (CSReport.data.dashboard.charts.trend) {
                new CSLineChart('execution-trend-chart', CSReport.data.dashboard.charts.trend);
            }
        }
    }
    
    function initializeGallery() {
        const lightbox = document.getElementById('cs-lightbox');
        const lightboxImg = document.getElementById('cs-lightbox-img');
        const lightboxClose = document.querySelector('.cs-lightbox-close');
        
        // Gallery item clicks
        document.querySelectorAll('.cs-gallery-item').forEach(item => {
            item.addEventListener('click', () => {
                const img = item.querySelector('img');
                lightboxImg.src = img.src;
                lightbox.classList.add('active');
            });
        });
        
        // Close lightbox
        lightboxClose.addEventListener('click', () => {
            lightbox.classList.remove('active');
        });
        
        lightbox.addEventListener('click', (e) => {
            if (e.target === lightbox) {
                lightbox.classList.remove('active');
            }
        });
    }
    
    function initializeTables() {
        // Add sorting to tables
        document.querySelectorAll('.cs-table').forEach(table => {
            const headers = table.querySelectorAll('th');
            headers.forEach((header, index) => {
                header.style.cursor = 'pointer';
                header.addEventListener('click', () => {
                    sortTable(table, index);
                });
            });
        });
    }
    
    function sortTable(table, columnIndex) {
        const tbody = table.querySelector('tbody');
        const rows = Array.from(tbody.querySelectorAll('tr'));
        const isNumeric = rows.every(row => !isNaN(row.cells[columnIndex].textContent));
        
        rows.sort((a, b) => {
            const aValue = a.cells[columnIndex].textContent;
            const bValue = b.cells[columnIndex].textContent;
            
            if (isNumeric) {
                return parseFloat(aValue) - parseFloat(bValue);
            } else {
                return aValue.localeCompare(bValue);
            }
        });
        
        // Toggle sort direction
        if (table.dataset.sortColumn === columnIndex.toString() && 
            table.dataset.sortDirection === 'asc') {
            rows.reverse();
            table.dataset.sortDirection = 'desc';
        } else {
            table.dataset.sortDirection = 'asc';
        }
        table.dataset.sortColumn = columnIndex.toString();
        
        // Re-append rows
        rows.forEach(row => tbody.appendChild(row));
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeReport);
    } else {
        initializeReport();
    }
})();
`;
    }

    /**
     * Generate SVG definitions
     */
    private generateSVGDefinitions(): string {
        return `
            <!-- Gradients -->
            <linearGradient id="cs-gradient-primary" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:${this.theme.primaryColor};stop-opacity:1" />
                <stop offset="100%" style="stop-color:${this.theme.accentColor};stop-opacity:1" />
            </linearGradient>
            
            <linearGradient id="cs-gradient-success" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:${this.theme.successColor};stop-opacity:1" />
                <stop offset="100%" style="stop-color:#20C997;stop-opacity:1" />
            </linearGradient>
            
            <linearGradient id="cs-gradient-error" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:${this.theme.errorColor};stop-opacity:1" />
                <stop offset="100%" style="stop-color:#C82333;stop-opacity:1" />
            </linearGradient>
            
            <!-- Patterns -->
            <pattern id="cs-pattern-dots" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                <circle cx="2" cy="2" r="1" fill="${this.theme.primaryColor}" opacity="0.2" />
            </pattern>
            
            <!-- Filters -->
            <filter id="cs-shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                <feOffset dx="0" dy="2" result="offsetblur"/>
                <feFlood flood-color="#000000" flood-opacity="0.2"/>
                <feComposite in2="offsetblur" operator="in"/>
                <feMerge>
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
            
            <!-- Icons -->
            <symbol id="icon-check" viewBox="0 0 24 24">
                <path d="M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"/>
            </symbol>
            
            <symbol id="icon-x" viewBox="0 0 24 24">
                <path d="M24 20.188l-8.315-8.209 8.2-8.282-3.697-3.697-8.212 8.318-8.31-8.203-3.666 3.666 8.321 8.24-8.206 8.313 3.666 3.666 8.237-8.318 8.285 8.203z"/>
            </symbol>
            
            <symbol id="icon-warning" viewBox="0 0 24 24">
                <path d="M12 2l11 19h-22zm0 3.516l-8.516 14.484h17.032zm-1 5.984v4h2v-4zm0 6v2h2v-2z"/>
            </symbol>
            
            <symbol id="icon-clock" viewBox="0 0 24 24">
                <path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm1 12v-6h-2v8h7v-2h-5z"/>
            </symbol>
            
            <symbol id="icon-search" viewBox="0 0 24 24">
                <path d="M23.809 21.646l-6.205-6.205c1.167-1.605 1.857-3.579 1.857-5.711 0-5.365-4.365-9.73-9.731-9.73-5.365 0-9.73 4.365-9.73 9.73 0 5.366 4.365 9.73 9.73 9.73 2.034 0 3.923-.627 5.487-1.698l6.238 6.238 2.354-2.354zm-20.955-11.916c0-3.792 3.085-6.877 6.877-6.877s6.877 3.085 6.877 6.877-3.085 6.877-6.877 6.877c-3.793 0-6.877-3.085-6.877-6.877z"/>
            </symbol>
            
            <symbol id="icon-download" viewBox="0 0 24 24">
                <path d="M12 21l-8-9h6v-12h4v12h6l-8 9zm9-1v2h-18v-2h-2v4h22v-4h-2z"/>
            </symbol>
        `;
    }

    /**
     * Generate header section
     */
    private generateHeader(metadata: any): string {
        return `
        <header class="cs-header">
            <div class="cs-header-content">
                <h1 class="cs-header-title">${metadata.reportTitle}</h1>
                <p class="cs-header-subtitle">${metadata.companyName} - Test Execution Report</p>
                <div class="cs-header-meta">
                    <div class="cs-header-meta-item">
                        <svg class="cs-header-meta-icon"><use xlink:href="#icon-clock"></use></svg>
                        <span>Generated: ${DateUtils.formatDate(new Date(metadata.reportGeneratedAt), 'MMMM DD, YYYY HH:mm:ss')}</span>
                    </div>
                    <div class="cs-header-meta-item">
                        <svg class="cs-header-meta-icon"><use xlink:href="#icon-clock"></use></svg>
                        <span>Duration: ${this.formatDuration(metadata.executionDuration)}</span>
                    </div>
                    <div class="cs-header-meta-item">
                        <span>Environment: <strong>${metadata.environment}</strong></span>
                    </div>
                    <div class="cs-header-meta-item">
                        <span>Report ID: <strong>${metadata.reportId}</strong></span>
                    </div>
                </div>
            </div>
        </header>
        `;
    }

    /**
     * Generate navigation
     */
    private generateNavigation(): string {
        return `
        <nav class="cs-nav">
            <div class="cs-nav-content">
                <ul class="cs-nav-links">
                    <li><a href="#summary" class="cs-nav-link active">Summary</a></li>
                    <li><a href="#dashboard" class="cs-nav-link">Dashboard</a></li>
                    <li><a href="#features" class="cs-nav-link">Features</a></li>
                    <li><a href="#scenarios" class="cs-nav-link">Scenarios</a></li>
                    <li><a href="#timeline" class="cs-nav-link">Timeline</a></li>
                    <li><a href="#gallery" class="cs-nav-link">Gallery</a></li>
                    <li><a href="#metrics" class="cs-nav-link">Metrics</a></li>
                </ul>
                <div class="cs-nav-actions">
                    <button class="cs-btn cs-btn-secondary" id="search-btn">
                        <svg width="16" height="16"><use xlink:href="#icon-search"></use></svg>
                        Search
                    </button>
                    <button class="cs-btn cs-btn-primary" id="export-btn">
                        <svg width="16" height="16"><use xlink:href="#icon-download"></use></svg>
                        Export
                    </button>
                </div>
            </div>
        </nav>
        `;
    }

    /**
     * Generate summary section
     */
    private generateSummarySection(summary: any): string {
        if (!summary || !summary.data) return '';
        
        const data = summary.data;
        
        return `
            <div class="cs-section-content">
                <div class="cs-section-header">
                    <h2 class="cs-section-title">Execution Summary</h2>
                    <p class="cs-section-subtitle">Overall test execution results and statistics</p>
                </div>
                
                <div class="cs-grid cs-grid-4 cs-mb-4">
                    <div class="cs-stat-card ${data.executionStatus === 'passed' ? 'success' : 'error'}">
                        <div class="cs-stat-value">${data.scenarioPassRate}%</div>
                        <div class="cs-stat-label">Pass Rate</div>
                        <svg class="cs-stat-icon"><use xlink:href="#icon-check"></use></svg>
                    </div>
                    
                    <div class="cs-stat-card">
                        <div class="cs-stat-value">${data.totalScenarios}</div>
                        <div class="cs-stat-label">Total Scenarios</div>
                    </div>
                    
                    <div class="cs-stat-card success">
                        <div class="cs-stat-value">${data.passedScenarios}</div>
                        <div class="cs-stat-label">Passed</div>
                    </div>
                    
                    <div class="cs-stat-card error">
                        <div class="cs-stat-value">${data.failedScenarios}</div>
                        <div class="cs-stat-label">Failed</div>
                    </div>
                </div>
                
                <div class="cs-grid cs-grid-2">
                    <div class="cs-card">
                        <div class="cs-card-header">
                            <h3 class="cs-card-title">Scenario Status Distribution</h3>
                        </div>
                        <div id="scenario-status-chart" class="cs-chart-container"></div>
                    </div>
                    
                    <div class="cs-card">
                        <div class="cs-card-header">
                            <h3 class="cs-card-title">Execution Details</h3>
                        </div>
                        <table class="cs-table">
                            <tbody>
                                <tr>
                                    <td>Total Features</td>
                                    <td><strong>${data.totalFeatures}</strong></td>
                                </tr>
                                <tr>
                                    <td>Total Steps</td>
                                    <td><strong>${data.totalSteps}</strong></td>
                                </tr>
                                <tr>
                                    <td>Step Pass Rate</td>
                                    <td><strong>${data.stepPassRate}%</strong></td>
                                </tr>
                                <tr>
                                    <td>Execution Time</td>
                                    <td><strong>${this.formatDuration(data.totalDuration)}</strong></td>
                                </tr>
                                <tr>
                                    <td>Average Scenario Duration</td>
                                    <td><strong>${this.formatDuration(data.averageScenarioDuration)}</strong></td>
                                </tr>
                                <tr>
                                    <td>Parallel Execution</td>
                                    <td><strong>${data.parallel ? 'Yes' : 'No'}</strong></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Generate dashboard section
     */
    private generateDashboard(dashboard: any): string {
        if (!dashboard || !dashboard.data) return '';
        
        return `
            <div class="cs-section-content">
                <div class="cs-section-header">
                    <h2 class="cs-section-title">Test Dashboard</h2>
                    <p class="cs-section-subtitle">Comprehensive test execution analytics and insights</p>
                </div>
                
                ${this.generateDashboardStats(dashboard.data.stats)}
                ${this.generateDashboardCharts(dashboard.data.charts)}
                ${this.generateDashboardInsights(dashboard.data.insights)}
            </div>
        `;
    }

    /**
     * Generate dashboard statistics
     */
    private generateDashboardStats(stats: any): string {
        if (!stats) return '';
        
        return `
            <div class="cs-grid cs-grid-4 cs-mb-4">
                ${stats.map((stat: any) => `
                    <div class="cs-stat-card ${stat.trend === 'up' ? 'success' : stat.trend === 'down' ? 'error' : ''}">
                        <div class="cs-stat-value">${stat.value}</div>
                        <div class="cs-stat-label">${stat.label}</div>
                        ${stat.change ? `<div class="cs-stat-change ${stat.trend}">${stat.change}</div>` : ''}
                    </div>
                `).join('')}
            </div>
        `;
    }

    /**
     * Generate dashboard charts
     */
    private generateDashboardCharts(charts: any): string {
        if (!charts) return '';
        
        return `
            <div class="cs-grid cs-grid-2 cs-mb-4">
                ${charts.trend ? `
                    <div class="cs-card">
                        <div class="cs-card-header">
                            <h3 class="cs-card-title">Execution Trend</h3>
                        </div>
                        <div id="execution-trend-chart" class="cs-chart-container"></div>
                    </div>
                ` : ''}
                
                ${charts.featureHealth ? `
                    <div class="cs-card">
                        <div class="cs-card-header">
                            <h3 class="cs-card-title">Feature Health</h3>
                        </div>
                        <div id="feature-health-chart" class="cs-chart-container"></div>
                    </div>
                ` : ''}
            </div>
            
            ${charts.performance ? `
                <div class="cs-card cs-mb-4">
                    <div class="cs-card-header">
                        <h3 class="cs-card-title">Performance Metrics</h3>
                    </div>
                    <div id="feature-performance-chart" class="cs-chart-container"></div>
                </div>
            ` : ''}
        `;
    }

    /**
     * Generate dashboard insights
     */
    private generateDashboardInsights(insights: any): string {
        if (!insights || insights.length === 0) return '';
        
        return `
            <div class="cs-card">
                <div class="cs-card-header">
                    <h3 class="cs-card-title">Key Insights</h3>
                </div>
                <div class="cs-insights">
                    ${insights.map((insight: any) => `
                        <div class="cs-insight ${insight.type}">
                            <div class="cs-insight-icon">
                                <svg width="24" height="24">
                                    <use xlink:href="#icon-${insight.type === 'success' ? 'check' : insight.type === 'error' ? 'x' : 'warning'}"></use>
                                </svg>
                            </div>
                            <div class="cs-insight-content">
                                <div class="cs-insight-title">${insight.title}</div>
                                <div class="cs-insight-description">${insight.description}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    /**
     * Generate features section
     */
    private generateFeaturesSection(features: any): string {
        if (!features || !features.data) return '';
        
        return `
            <div class="cs-section-content">
                <div class="cs-section-header">
                    <h2 class="cs-section-title">Feature Results</h2>
                    <p class="cs-section-subtitle">Detailed results for each feature</p>
                </div>
                
                <div class="cs-grid cs-grid-2">
                    ${features.data.map((feature: any) => this.generateFeatureCard(feature)).join('')}
                </div>
            </div>
        `;
    }

    /**
     * Generate feature card
     */
    private generateFeatureCard(feature: any): string {
        const passRate = Math.round((feature.passed / feature.total) * 100);
        
        return `
            <div class="cs-card">
                <div class="cs-card-header">
                    <h3 class="cs-card-title">${feature.name}</h3>
                    <span class="cs-card-badge ${feature.status}">${feature.status}</span>
                </div>
                
                <div class="cs-feature-stats">
                    <div class="cs-feature-stat">
                        <span class="cs-feature-stat-value">${feature.total}</span>
                        <span class="cs-feature-stat-label">Scenarios</span>
                    </div>
                    <div class="cs-feature-stat">
                        <span class="cs-feature-stat-value cs-text-success">${feature.passed}</span>
                        <span class="cs-feature-stat-label">Passed</span>
                    </div>
                    <div class="cs-feature-stat">
                        <span class="cs-feature-stat-value cs-text-error">${feature.failed}</span>
                        <span class="cs-feature-stat-label">Failed</span>
                    </div>
                    <div class="cs-feature-stat">
                        <span class="cs-feature-stat-value">${this.formatDuration(feature.duration)}</span>
                        <span class="cs-feature-stat-label">Duration</span>
                    </div>
                </div>
                
                <div class="cs-progress ${feature.status}">
                    <div class="cs-progress-bar" style="width: ${passRate}%"></div>
                </div>
                
                ${feature.tags && feature.tags.length > 0 ? `
                    <div class="cs-tags cs-mt-3">
                        ${feature.tags.map((tag: string) => `<span class="cs-tag">${tag}</span>`).join('')}
                    </div>
                ` : ''}
            </div>
        `;
    }

    /**
     * Generate scenarios section
     */
    private generateScenariosSection(scenarios: any): string {
        if (!scenarios || !scenarios.data) return '';
        
        return `
            <div class="cs-section-content">
                <div class="cs-section-header">
                    <h2 class="cs-section-title">Scenario Details</h2>
                    <p class="cs-section-subtitle">Step-by-step execution details for all scenarios</p>
                </div>
                
                <div class="cs-scenario-filters cs-mb-4">
                    <button class="cs-btn cs-btn-secondary active" data-filter="all">All</button>
                    <button class="cs-btn cs-btn-secondary" data-filter="passed">Passed</button>
                    <button class="cs-btn cs-btn-secondary" data-filter="failed">Failed</button>
                    <button class="cs-btn cs-btn-secondary" data-filter="skipped">Skipped</button>
                </div>
                
                <div class="cs-scenarios">
                    ${scenarios.data.map((scenario: any) => this.generateScenarioDetails(scenario)).join('')}
                </div>
            </div>
        `;
    }

    /**
     * Generate scenario details
     */
    private generateScenarioDetails(scenario: any): string {
        return `
            <div class="cs-scenario ${scenario.status}" data-scenario-id="${scenario.id}" data-status="${scenario.status}">
                <div class="cs-scenario-header">
                    <div class="cs-scenario-info">
                        <h4 class="cs-scenario-name">${scenario.name}</h4>
                        <div class="cs-scenario-meta">
                            <span class="cs-scenario-feature">${scenario.feature}</span>
                            <span class="cs-scenario-duration">${this.formatDuration(scenario.duration)}</span>
                        </div>
                    </div>
                    <div class="cs-scenario-status">
                        <span class="cs-table-status ${scenario.status}">
                            <svg class="cs-table-icon">
                                <use xlink:href="#icon-${scenario.status === 'passed' ? 'check' : scenario.status === 'failed' ? 'x' : 'warning'}"></use>
                            </svg>
                            ${scenario.status}
                        </span>
                    </div>
                </div>
                
                <div class="cs-scenario-steps">
                    ${scenario.steps.map((step: any) => this.generateStepDetails(step)).join('')}
                </div>
                
                ${scenario.error ? `
                    <div class="cs-scenario-error">
                        <div class="cs-error-title">Error Details</div>
                        <pre class="cs-error-message">${this.escapeHtml(scenario.error.message)}</pre>
                        ${scenario.error.stack ? `
                            <details class="cs-error-stack">
                                <summary>Stack Trace</summary>
                                <pre>${this.escapeHtml(scenario.error.stack)}</pre>
                            </details>
                        ` : ''}
                    </div>
                ` : ''}
                
                ${scenario.screenshot ? `
                    <div class="cs-scenario-screenshot">
                        <img src="${scenario.screenshot}" alt="Failure screenshot" class="cs-screenshot-thumb" />
                    </div>
                ` : ''}
            </div>
        `;
    }

    /**
     * Generate step details
     */
    private generateStepDetails(step: any): string {
        return `
            <div class="cs-step ${step.status}">
                <div class="cs-step-status">
                    <svg class="cs-step-icon">
                        <use xlink:href="#icon-${step.status === 'passed' ? 'check' : step.status === 'failed' ? 'x' : 'warning'}"></use>
                    </svg>
                </div>
                <div class="cs-step-content">
                    <div class="cs-step-name">${step.keyword} ${step.name}</div>
                    ${step.duration ? `<div class="cs-step-duration">${step.duration}ms</div>` : ''}
                    ${step.error ? `
                        <div class="cs-step-error">
                            <pre>${this.escapeHtml(step.error.message)}</pre>
                        </div>
                    ` : ''}
                    ${step.logs && step.logs.length > 0 ? `
                        <details class="cs-step-logs">
                            <summary>Action Logs (${step.logs.length})</summary>
                            <div class="cs-logs">
                                ${step.logs.map((log: any) => `
                                    <div class="cs-log ${log.level}">
                                        <span class="cs-log-time">${DateUtils.formatDate(new Date(log.timestamp), 'HH:mm:ss.SSS')}</span>
                                        <span class="cs-log-message">${this.escapeHtml(log.message)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                    ` : ''}
                </div>
            </div>
        `;
    }

    /**
     * Generate timeline section
     */
    private generateTimelineSection(timeline: any): string {
        if (!timeline || !timeline.data) return '';
        
        return `
            <div class="cs-section-content">
                <div class="cs-section-header">
                    <h2 class="cs-section-title">Execution Timeline</h2>
                    <p class="cs-section-subtitle">Visual representation of test execution flow</p>
                </div>
                
                <div id="execution-timeline" class="cs-timeline"></div>
                
                <script>
                    // Timeline data embedded for initialization
                    window.timelineData = ${JSON.stringify(timeline.data)};
                </script>
            </div>
        `;
    }

    /**
     * Generate gallery section
     */
    private generateGallerySection(gallery: any): string {
        if (!gallery || !gallery.data || gallery.data.length === 0) return '';
        
        return `
            <div class="cs-section-content">
                <div class="cs-section-header">
                    <h2 class="cs-section-title">Screenshot Gallery</h2>
                    <p class="cs-section-subtitle">Visual evidence from test execution</p>
                </div>
                
                <div class="cs-gallery">
                    ${gallery.data.map((item: any) => `
                        <div class="cs-gallery-item">
                            <img src="${item.url}" alt="${item.caption}" loading="lazy" />
                            <div class="cs-gallery-overlay">
                                <div class="cs-gallery-caption">${item.caption}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    /**
     * Generate metrics section
     */
    private generateMetricsSection(metrics: any): string {
        if (!metrics || !metrics.data) return '';
        
        return `
            <div class="cs-section-content">
                <div class="cs-section-header">
                    <h2 class="cs-section-title">Performance Metrics</h2>
                    <p class="cs-section-subtitle">Detailed performance analysis</p>
                </div>
                
                <div class="cs-grid cs-grid-3 cs-mb-4">
                    ${this.generateMetricCards(metrics.data.summary)}
                </div>
                
                ${metrics.data.breakdown ? this.generateMetricsBreakdown(metrics.data.breakdown) : ''}
                ${metrics.data.trends ? this.generateMetricsTrends(metrics.data.trends) : ''}
            </div>
        `;
    }

    /**
     * Generate metric cards
     */
    private generateMetricCards(summary: any): string {
        if (!summary) return '';
        
        return Object.entries(summary).map(([key, value]: [string, any]) => `
            <div class="cs-card">
                <div class="cs-metric-value">${value.value}</div>
                <div class="cs-metric-label">${value.label}</div>
                ${value.comparison ? `
                    <div class="cs-metric-comparison ${value.trend}">
                        ${value.comparison} vs previous
                    </div>
                ` : ''}
            </div>
        `).join('');
    }

    /**
     * Generate metrics breakdown
     */
    private generateMetricsBreakdown(breakdown: any): string {
        return `
            <div class="cs-card">
                <div class="cs-card-header">
                    <h3 class="cs-card-title">Performance Breakdown</h3>
                </div>
                <div class="cs-table-container">
                    <table class="cs-table">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>Min</th>
                                <th>Max</th>
                                <th>Average</th>
                                <th>P95</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${Object.entries(breakdown).map(([metric, values]: [string, any]) => `
                                <tr>
                                    <td>${metric}</td>
                                    <td>${this.formatMetricValue(values.min)}</td>
                                    <td>${this.formatMetricValue(values.max)}</td>
                                    <td>${this.formatMetricValue(values.avg)}</td>
                                    <td>${this.formatMetricValue(values.p95)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }

    /**
     * Generate metrics trends
     */
    private generateMetricsTrends(trends: any): string {
        return `
            <div class="cs-card cs-mt-4">
                <div class="cs-card-header">
                    <h3 class="cs-card-title">Performance Trends</h3>
                </div>
                <div id="metrics-trend-chart" class="cs-chart-container"></div>
            </div>
        `;
    }

    /**
     * Generate footer
     */
    private generateFooter(metadata: any): string {
        return `
            <footer class="cs-footer">
                <div class="cs-footer-content">
                    <div class="cs-footer-info">
                        <p>Generated by <strong>${metadata.frameworkName}</strong> v${metadata.frameworkVersion}</p>
                        <p> ${new Date().getFullYear()} ${metadata.companyName}. All rights reserved.</p>
                    </div>
                    <div class="cs-footer-links">
                        <a href="#" onclick="window.print(); return false;">Print Report</a>
                        <a href="#" onclick="CSReport.exportJSON(); return false;">Export JSON</a>
                        <a href="#" onclick="CSReport.shareReport(); return false;">Share</a>
                    </div>
                </div>
            </footer>
        `;
    }

    /**
     * Helper method to escape HTML
     */
    private escapeHtml(text: string): string {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Helper method to format duration
     */
    private formatDuration(ms: number): string {
        if (ms < 1000) return `${ms}ms`;
        if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);
        return `${minutes}m ${seconds}s`;
    }

    /**
     * Helper method to format metric values
     */
    private formatMetricValue(value: any): string {
        if (typeof value === 'number') {
            if (value < 1) return `${(value * 1000).toFixed(0)}ms`;
            if (value < 1000) return `${value.toFixed(0)}ms`;
            return `${(value / 1000).toFixed(1)}s`;
        }
        return value;
    }

    /**
     * Helper method to convert hex to RGB
     */
    private hexToRgb(hex: string): number[] {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ] : [0, 0, 0];
    }

    /**
     * Save report to file
     */
    public async saveReport(html: string, outputPath: string): Promise<void> {
        try {
            const dir = path.dirname(outputPath);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }

            fs.writeFileSync(outputPath, html, 'utf8');
            this.logger.info(`HTML report saved to: ${outputPath}`);
        } catch (error) {
            this.logger.error('Failed to save HTML report', error);
            throw error;
        }
    }
}